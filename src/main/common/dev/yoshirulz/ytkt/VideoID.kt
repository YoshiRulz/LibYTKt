package dev.yoshirulz.ytkt

import io.ktor.client.request.get
import io.ktor.http.Parameters
import io.ktor.http.parametersOf
import io.ktor.http.parseUrlEncodedParameters
import io.ktor.util.KtorExperimentalAPI
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlin.time.ExperimentalTime
import kotlin.time.seconds

@UseExperimental(ExperimentalTime::class, ExperimentalUnsignedTypes::class, KtorExperimentalAPI::class)
data class VideoID internal constructor(val raw: String) {
	/** The video player page */
	val canonicalURI: URI get() = ytCanonicalURI("/watch", parametersOf("v", raw))

	/** The embedded player page */
	val embedURI: URI get() = ytCanonicalURI("/embed/$raw")

	/** Like [linkedSimilarPlaylist], but limited to the same channel as this video */
	@EntryPoint
	val linkedSameChannelSimilarPlaylist: PlaylistID get() = PlaylistID("UL$raw", PlaylistID.Companion.PlaylistType.SameChannelMix)

	/** The autogenerated "YouTube Mix" playlist, populated with similar videos */
	@EntryPoint
	val linkedSimilarPlaylist: PlaylistID get() = PlaylistID("RD$raw", PlaylistID.Companion.PlaylistType.YouTubeMix)

	/** A shortened URI that redirects to the video player page */
	val shortURI: URI get() = ytCanonicalURI("/$raw", isShortened = true)

	@RequiresXMLParser
	private suspend fun getPlayerConfig(scraper: YTKtScraper): PlayerConfiguration {
		// first, scrape the embed page
		val responseAJSON = YTEmbedPagePlayerConfig.parse(scraper.getAndParseHTML(embedURI.copy(parameters = parametersOf("disable_polymer", "true"))).source.text
			.substringAfter("yt.setConfig({'PLAYER_CONFIG': ", EMPTY_STRING)
			.substringBefore("});writeEmbed();</script>", EMPTY_STRING)
			.ifEmpty { // couldn't get the JSON string from the response
				throw VideoUnplayableException(this)
			})
		val requestTimestampB = Timestamp.now()
		val responseB = getVideoInfoMap(scraper)
		val responseBJSON = YTPlayerResponse.parse(responseB["player_response"]!!)
		if ("error".equals(responseBJSON.playabilityStatus?.status, ignoreCase = true)) throw VideoUnavailableException(this)
		if (responseBJSON.playabilityStatus?.reason.isNullOrBlank()) { // no error reason given means there was no error i.e. it succeeded, extract info and return
			return PlayerConfiguration.fromYTPlayerResponse(
				responseBJSON,
				responseAJSON.assets.js,
				requestTimestampB + responseBJSON.streamingData!!.expiresInSeconds.seconds,
				responseB["url_encoded_fmt_stream_map"],
				responseB["adaptive_fmts"])
		} else { // couldn't get the data linked from the embed page
			// two checks for premium (non-gratis) content
			responseBJSON.playabilityStatus?.errorScreen?.playerLegacyDesktopYpcTrailerRenderer?.trailerVideoId?.let {
				if (it.isNotBlank()) throw VideoRequiresPurchaseException(this, it)
			}
			responseBJSON.playabilityStatus?.errorScreen?.ypcTrailerRenderer?.playerVars?.let {
				if (it.isNotBlank()) throw VideoRequiresPurchaseException(this, it.parseUrlEncodedParameters()["video_id"]!!)
			}

			// there was some other error, move on to scraping the watch page
			val requestTimestampC = Timestamp.now()
			val responseCStructured = getVideoPageBody(scraper)
			val responseCRaw = responseCStructured.source.text
				.substringAfter("ytplayer.config = ", EMPTY_STRING)
				.substringBefore(";ytplayer.load = function() {yt.player.Application.create(\"player-api\", ytplayer.config);ytplayer.config.loaded = true;};(function() {if (!!window.yt && yt.player && yt.player.Application) {ytplayer.load();}}());</script>", EMPTY_STRING)
				.ifEmpty { // couldn't get the JSON string from the response
					throw VideoUnplayableException(this, responseCStructured.querySelector("#unavailable-message")?.textContent?.trim())
				}
			val responseCJSON = YTWatchPagePlayerConfig.parse(responseCRaw)
			val responseDJSON = YTPlayerResponse.parse(responseCJSON.args.player_response)
			return PlayerConfiguration.fromYTPlayerResponse(
				responseDJSON,
				responseCJSON.assets.js,
				requestTimestampC + responseDJSON.streamingData!!.expiresInSeconds.seconds,
				responseCJSON.args.url_encoded_fmt_stream_map,
				responseCJSON.args.adaptive_fmts)
		}
	}

	private suspend fun getVideoInfoMap(scraper: YTKtScraper) = scraper.httpClient.get<String>(ytCanonicalURI(
		"/get_video_info",
		parametersOf("video_id" to listOf(raw), "el" to listOf("embedded"), "eurl" to listOf("https%3A%2F%2Fyoutube.googleapis.com%2Fv%2F$raw"), "hl" to listOf("en"))
	)).parseUrlEncodedParameters()

	@RequiresXMLParser
	private suspend fun getVideoPageBody(scraper: YTKtScraper) = scraper.getAndParseHTML(canonicalURI.copy(parameters = parametersOf("v" to listOf(raw), "disable_polymer" to listOf("true"), "bpctr" to listOf("9999999999"))))

	private fun getVideoPlayerResponse(parameters: Parameters) = YTPlayerResponse.parse(parameters["player_response"]!!)

	private suspend fun getVideoPlayerResponse(scraper: YTKtScraper) = getVideoPlayerResponse(getVideoInfoMap(scraper))

	suspend fun getCCMetadata(scraper: YTKtScraper): List<CCTrackMetadata> = getVideoPlayerResponse(scraper).let {
		if ("error".equals(it.playabilityStatus?.status, ignoreCase = true)) throw VideoUnavailableException(this)
		else it.captions!!.playerCaptionsTracklistRenderer.captionTracks.orEmpty().map(CCTrackMetadata.Companion::fromJSON)
	}

	@RequiresXMLParser
	suspend fun getData(scraper: YTKtScraper): Video = coroutineScope {
		val playerResponseRequest = async { getVideoPlayerResponse(scraper) }
		val watchPageBodyRequest = async { getVideoPageBody(scraper) }
		val playerResponse = playerResponseRequest.await()
		if ("error".equals(playerResponse.playabilityStatus?.status, ignoreCase = true)) throw VideoUnavailableException(this@VideoID)
		val videoDetails = playerResponse.videoDetails!!
		val watchPageBody = watchPageBodyRequest.await()
		Video(
			this@VideoID,
			videoDetails.author,
			Timestamp.fromYMDString(watchPageBody.querySelector("meta[itemprop=\"datePublished\"]")!!.getAttribute("content")),
			videoDetails.title,
			videoDetails.shortDescription,
			videoDetails.lengthSeconds.seconds,
			videoDetails.keywords.orEmpty(),
			videoDetails.viewCount?.toULong() ?: 0UL, // some videos have no viewCount
			watchPageBody.querySelector("button.like-button-renderer-like-button")?.text?.stripNonDigit()?.toULong() ?: 0UL,
			watchPageBody.querySelector("button.like-button-renderer-dislike-button")?.text?.stripNonDigit()?.toULong() ?: 0UL)
	}

	@RequiresXMLParser
	suspend fun getStreamMetadataSet(scraper: YTKtScraper): StreamMetadataSet = coroutineScope {
		val playerConfiguration = getPlayerConfig(scraper)

		val avStreamsMetadata = async {
			playerConfiguration.avMetadataUrlEncoded.orEmpty()
				.split(',')
				.filter { it.isNotEmpty() }
				.map { it.parseUrlEncodedParameters() }
				.mapNotNull { AudioVisualStreamMetadata.fromQueryParams(it, playerConfiguration.playerSourceURI, scraper.httpClient, scraper.decipherer) }
				.toList()
		}
		val adaptiveStreamsFromMetadata = async {
			StreamMetadata.adaptiveFromMetadata(scraper, playerConfiguration.playerSourceURI, playerConfiguration.adaptiveMetadataUrlEncoded.orEmpty())
		}
		val adaptiveStreamsFromDASH = async {
			playerConfiguration.dashManifestURI?.takeIf { it.isNotBlank() }?.let {
				StreamMetadata.adaptiveFromDASHManifest(scraper, playerConfiguration.playerSourceURI, it)
			} ?: Pair(emptyList(), emptyList())
		}

		val audioStreamsMetadata = mutableListOf<AudioOnlyStreamMetadata>()
		val videoStreamsMetadata = mutableListOf<VideoOnlyStreamMetadata>()
		adaptiveStreamsFromMetadata.await().let { (a, v) ->
			audioStreamsMetadata += a
			videoStreamsMetadata += v
		}
		adaptiveStreamsFromDASH.await().let { (a, v) ->
			audioStreamsMetadata += a
			videoStreamsMetadata += v
		}
		StreamMetadataSet(
			avStreamsMetadata.await().sortedByDescending { it.videoQuality },
			audioStreamsMetadata.sortedByDescending { it.bitrate },
			videoStreamsMetadata.sortedByDescending { it.videoQuality },
			playerConfiguration.validUntil,
			playerConfiguration.hlsManifestURI)
	}

	override fun toString() = raw

	companion object {
		private interface PlayerConfiguration {
			val playerSourceURI: String
			val validUntil: Timestamp
			val hlsManifestURI: String? get() = null
			val dashManifestURI: String? get() = null
			val avMetadataUrlEncoded: String? get() = null
			val adaptiveMetadataUrlEncoded: String? get() = null

			companion object {
				private data class LivePlayerConfig(override val playerSourceURI: String, override val validUntil: Timestamp, override val hlsManifestURI: String): PlayerConfiguration

				private data class VideoPlayerConfig(override val playerSourceURI: String, override val validUntil: Timestamp, override val dashManifestURI: String, override val avMetadataUrlEncoded: String, override val adaptiveMetadataUrlEncoded: String): PlayerConfiguration

				fun fromYTPlayerResponse(secondResponseJSON: YTPlayerResponse, playerSourceUrlRelative: String, validUntil: Timestamp, avMetadataUrlEncoded: String?, adaptiveMetadataUrlEncoded: String?) =
					"https://www.youtube.com$playerSourceUrlRelative".let { playerSourceUrl ->
						if (secondResponseJSON.videoDetails?.isLive == true)
							LivePlayerConfig(
								playerSourceUrl,
								validUntil,
								secondResponseJSON.streamingData!!.hlsManifestUrl!!
							)
						else
							VideoPlayerConfig(
								playerSourceUrl,
								validUntil,
								secondResponseJSON.streamingData!!.dashManifestUrl!!,
								avMetadataUrlEncoded!!,
								adaptiveMetadataUrlEncoded!!
							)
					}
			}
		}

		const val VIDEO_ID_PATTERN_FRAGMENT = """[\-0-9A-Z_a-z]{11}"""

		/** matches `yIVRs6YSbOM` */ //TODO censor-check all docs
		private val VIDEO_ID_PATTERN = Regex("^$VIDEO_ID_PATTERN_FRAGMENT\$")

		fun parse(raw: String): VideoID? = if (VIDEO_ID_PATTERN matches raw) VideoID(raw) else null

		fun parseFromURI(uri: URI): VideoID? = when (YouTubeDomain.ofURI(uri)) {
			YouTubeDomain.MainOrMirror -> when {
				uri.encodedPath.startsWith("/embed/") -> uri.encodedPath.substring(7)
				uri.encodedPath == "/watch" -> uri.parameters["v"]
				else -> null
			}
			YouTubeDomain.Short -> uri.encodedPath.substring(1)
			else -> null
		}?.let { parse(it) }
	}
}
