package dev.yoshirulz.ytkt

import io.ktor.client.HttpClient
import io.ktor.client.request.get
import io.ktor.http.parametersOf
import io.ktor.http.parseUrlEncodedParameters
import io.ktor.util.KtorExperimentalAPI
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlin.time.ExperimentalTime
import kotlin.time.seconds

@UseExperimental(ExperimentalTime::class, ExperimentalUnsignedTypes::class, KtorExperimentalAPI::class)
data class VideoID internal constructor(val raw: String) {
	/** The video player page. */
	val canonicalURI: URI get() = ytCanonicalURI("/watch", parametersOf("v", raw))

	/** The embedded player page. */
	val embedURI: URI get() = ytCanonicalURI("/embed/$raw")

	/** Like [linkedSimilarPlaylist], but limited to the same channel as this video. */
	val linkedSameChannelSimilarPlaylist: PlaylistID get() = PlaylistID("UL$raw", PlaylistID.Companion.PlaylistType.SameChannelMix)

	/** The autogenerated "YouTube Mix" playlist, populated with similar videos. */
	val linkedSimilarPlaylist: PlaylistID get() = PlaylistID("RD$raw", PlaylistID.Companion.PlaylistType.YouTubeMix)

	/** A shortened URI that redirects to the video player page. */
	val shortURI: URI get() = ytCanonicalURI("/$raw", isShortened = true)

	private suspend fun getPlayerConfig(httpClient: HttpClient): PlayerConfiguration {
		// first, scrape the embed page
		val responseAJSON = coroutineScope {
			YTEmbedPagePlayerConfig.parse(
				embedURI.copy(parameters = parametersOf("disable_polymer", "true"))
					.requestPlaintextProxied(httpClient, this)
					.receiveSingleOrElse { EMPTY_STRING }
					.substringAfter("yt.setConfig({'PLAYER_CONFIG': ", EMPTY_STRING)
					.substringBefore("});writeEmbed();</script>", EMPTY_STRING)
					.ifEmpty { throw VideoUnplayableException(this@VideoID) } // couldn't get the JSON string from the response
			)
		}
		val requestTimestampB = Timestamp.now()
		val responseB = getVideoInfoMap(httpClient)
		val responseBJSON = YTPlayerResponse.parse(responseB["player_response"]!!)
		if ("error".equals(responseBJSON.playabilityStatus?.status, ignoreCase = true)) throw VideoUnavailableException(this)
		if (responseBJSON.playabilityStatus?.reason.isNullOrBlank()) { // no error reason given means there was no error i.e. it succeeded, extract info and return
			return PlayerConfiguration.fromYTPlayerResponse(
				responseBJSON,
				responseAJSON.assets.js,
				requestTimestampB + responseBJSON.streamingData!!.expiresInSeconds.seconds,
				responseB["url_encoded_fmt_stream_map"],
				responseB["adaptive_fmts"]
			)
		} else { // couldn't get the data linked from the embed page
			// two checks for premium (non-gratis) content
			responseBJSON.playabilityStatus?.errorScreen?.playerLegacyDesktopYpcTrailerRenderer?.trailerVideoId?.let {
				if (it.isNotBlank()) throw VideoRequiresPurchaseException(this, it)
			}
			responseBJSON.playabilityStatus?.errorScreen?.ypcTrailerRenderer?.playerVars?.let {
				if (it.isNotBlank()) throw VideoRequiresPurchaseException(this, it.parseUrlEncodedParameters()["video_id"]!!)
			}

			// there was some other error, move on to scraping the watch page
			val requestTimestampC = Timestamp.now()
			val responseCStructured = getVideoPageBody(httpClient)
			val responseCRaw = responseCStructured.source.text
				.substringAfter("ytplayer.config = ", EMPTY_STRING)
				.substringBefore(";ytplayer.load = function() {yt.player.Application.create(\"player-api\", ytplayer.config);ytplayer.config.loaded = true;};(function() {if (!!window.yt && yt.player && yt.player.Application) {ytplayer.load();}}());</script>", EMPTY_STRING)
				.ifEmpty { throw VideoUnplayableException(this, responseCStructured.querySelector("#unavailable-message")?.textContent?.trim()) } // couldn't get the JSON string from the response
			val responseCJSON = YTWatchPagePlayerConfig.parse(responseCRaw)
			val responseDJSON = YTPlayerResponse.parse(responseCJSON.args.player_response)
			return PlayerConfiguration.fromYTPlayerResponse(
				responseDJSON,
				responseCJSON.assets.js,
				requestTimestampC + responseDJSON.streamingData!!.expiresInSeconds.seconds,
				responseCJSON.args.url_encoded_fmt_stream_map,
				responseCJSON.args.adaptive_fmts
			)
		}
	}

	private suspend fun getVideoInfoMap(httpClient: HttpClient) = httpClient.get<String>(ytCanonicalURI(
		"/get_video_info",
		parametersOf(
			"video_id" to listOf(raw),
			"el" to listOf("embedded"),
			"eurl" to listOf("https%3A%2F%2Fyoutube.googleapis.com%2Fv%2F$raw"),
			"hl" to listOf("en")
		)
	)).parseUrlEncodedParameters()

	private suspend fun getVideoPageBody(httpClient: HttpClient) = coroutineScope {
		canonicalURI.copy(parameters = parametersOf("v" to listOf(raw), "disable_polymer" to listOf("true"), "bpctr" to listOf("9999999999")))
			.requestPageProxied(httpClient, this)
			.receiveSingleOrElse { throw PageRequestFailureException() }
	}

	private suspend fun getVideoPlayerResponse(httpClient: HttpClient) = YTPlayerResponse.parse(getVideoInfoMap(httpClient)["player_response"]!!)

	suspend fun getCCMetadata(httpClient: HttpClient): List<CCTrackMetadata> = getVideoPlayerResponse(httpClient).let {
		if ("error".equals(it.playabilityStatus?.status, ignoreCase = true)) throw VideoUnavailableException(this)
		else it.captions!!.playerCaptionsTracklistRenderer.captionTracks.orEmpty().map(CCTrackMetadata.Companion::fromJSON)
	}

	suspend fun getData(httpClient: HttpClient): Video = coroutineScope {
		val playerResponseRequest = async { getVideoPlayerResponse(httpClient) }
		val watchPageBodyRequest = async { getVideoPageBody(httpClient) }
		val playerResponse = playerResponseRequest.await()
		if ("error".equals(playerResponse.playabilityStatus?.status, ignoreCase = true)) throw VideoUnavailableException(this@VideoID)
		val videoDetails = playerResponse.videoDetails!!
		val watchPageBody = watchPageBodyRequest.await()
		Video(
			this@VideoID,
			videoDetails.author,
			Timestamp.fromYMDString(watchPageBody.querySelector("meta[itemprop=\"datePublished\"]")!!.getAttribute("content")),
			videoDetails.title,
			videoDetails.shortDescription,
			videoDetails.lengthSeconds.seconds,
			videoDetails.keywords.orEmpty(),
			videoDetails.viewCount?.toULong() ?: 0UL, // some videos have no viewCount
			watchPageBody.querySelector("button.like-button-renderer-like-button")?.text?.stripNonDigit()?.toULong() ?: 0UL,
			watchPageBody.querySelector("button.like-button-renderer-dislike-button")?.text?.stripNonDigit()?.toULong() ?: 0UL
		)
	}

	suspend fun getStreamMetadataSet(httpClient: HttpClient, decipherer: Decipherer): StreamMetadataSet = coroutineScope {
		val playerConfiguration = getPlayerConfig(httpClient)

		val avStreamsMetadata = async {
			playerConfiguration.avMetadataUrlEncoded.orEmpty()
				.split(',')
				.filter { it.isNotEmpty() }
				.map { it.parseUrlEncodedParameters() }
				.mapNotNull { AudioVisualStreamMetadata.fromQueryParams(it, playerConfiguration.playerSourceURI, httpClient, decipherer) }
				.toList()
		}
		val adaptiveStreamsFromMetadata = async {
			StreamMetadata.adaptiveFromMetadata(httpClient, decipherer, playerConfiguration.playerSourceURI, playerConfiguration.adaptiveMetadataUrlEncoded.orEmpty())
		}
		val adaptiveStreamsFromDASH = async {
			playerConfiguration.dashManifestURI?.takeIf { it.isNotBlank() }?.let {
				StreamMetadata.adaptiveFromDASHManifest(httpClient, decipherer, playerConfiguration.playerSourceURI, it)
			} ?: Pair(emptyList(), emptyList())
		}

		val audioStreamsMetadata = mutableListOf<AudioOnlyStreamMetadata>()
		val videoStreamsMetadata = mutableListOf<VideoOnlyStreamMetadata>()
		adaptiveStreamsFromMetadata.await().let { (a, v) ->
			audioStreamsMetadata += a
			videoStreamsMetadata += v
		}
		adaptiveStreamsFromDASH.await().let { (a, v) ->
			audioStreamsMetadata += a
			videoStreamsMetadata += v
		}
		StreamMetadataSet(
			avStreamsMetadata.await().sortedByDescending { it.videoQuality },
			audioStreamsMetadata.sortedByDescending { it.bitrate },
			videoStreamsMetadata.sortedByDescending { it.videoQuality },
			playerConfiguration.validUntil,
			playerConfiguration.hlsManifestURI
		)
	}

	override fun toString() = raw

	companion object {
		private interface PlayerConfiguration {
			val playerSourceURI: String
			val validUntil: Timestamp
			val hlsManifestURI: String? get() = null
			val dashManifestURI: String? get() = null
			val avMetadataUrlEncoded: String? get() = null
			val adaptiveMetadataUrlEncoded: String? get() = null

			companion object {
				private data class LivePlayerConfig(override val playerSourceURI: String, override val validUntil: Timestamp, override val hlsManifestURI: String): PlayerConfiguration

				private data class VideoPlayerConfig(override val playerSourceURI: String, override val validUntil: Timestamp, override val dashManifestURI: String, override val avMetadataUrlEncoded: String, override val adaptiveMetadataUrlEncoded: String): PlayerConfiguration

				fun fromYTPlayerResponse(secondResponseJSON: YTPlayerResponse, playerSourceUrlRelative: String, validUntil: Timestamp, avMetadataUrlEncoded: String?, adaptiveMetadataUrlEncoded: String?) =
					"https://www.youtube.com$playerSourceUrlRelative".let { playerSourceUrl ->
						if (secondResponseJSON.videoDetails?.isLive == true)
							LivePlayerConfig(
								playerSourceUrl,
								validUntil,
								secondResponseJSON.streamingData!!.hlsManifestUrl!!
							)
						else
							VideoPlayerConfig(
								playerSourceUrl,
								validUntil,
								secondResponseJSON.streamingData!!.dashManifestUrl!!,
								avMetadataUrlEncoded!!,
								adaptiveMetadataUrlEncoded!!
							)
					}
			}
		}

		const val VIDEO_ID_PATTERN_FRAGMENT = """[\-0-9A-Z_a-z]{11}"""

		/** matches `yIVRs6YSbOM` */ //TODO censor-check all docs
		private val VIDEO_ID_PATTERN = Regex("^$VIDEO_ID_PATTERN_FRAGMENT\$")

		fun parse(raw: String): VideoID? = if (VIDEO_ID_PATTERN matches raw) VideoID(raw) else null

		@EntryPoint
		fun parseFromURI(uri: String): VideoID? = parseFromURI(uri.parseURI())

		fun parseFromURI(uri: URI): VideoID? = when (YouTubeDomain.ofURI(uri)) {
			YouTubeDomain.MainOrMirror -> when {
				uri.encodedPath.startsWith("/embed/") -> uri.encodedPath.substring(7)
				uri.encodedPath == "/watch" -> uri.parameters["v"]
				else -> null
			}
			YouTubeDomain.Short -> uri.encodedPath.substring(1)
			else -> null
		}?.let { parse(it) }
	}
}
